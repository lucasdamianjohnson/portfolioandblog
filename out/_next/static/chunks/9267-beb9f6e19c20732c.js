(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9267],{20123:function(){},36600:function(t,r,a){"use strict";var e,i,y,c;a.d(r,{h7:function(){return o},Ji:function(){return s},Yp:function(){return u}});class s{static ApplyMatrix(t,r){return{x:t[0]*r.x+t[1]*r.y+t[2],y:t[3]*r.x+t[4]*r.y+t[5]}}static ApplyMatrixArray(t,r){return[t[0]*r[0]+t[1]*r[1]+t[2],t[3]*r[0]+t[4]*r[1]+t[5]]}static RotateAroundPivot(t,r,a){let e={x:r.x-a.x,y:r.y-a.y},i=s.ApplyMatrix(t,e);return{x:i.x+a.x,y:i.y+a.y}}static RotateAroundPivotArray(t,r,a){let e=[r[0]-a[0],r[1]-a[1]],i=s.ApplyMatrixArray(t,e);return[i[0]+a[0],i[1]+a[1]]}static Create(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new s(t,r)}static Add(t,r){return{x:t.x+r.x,y:t.y+r.y}}static AddToRef(t,r,a){a.x=t.x+r.x,a.y=t.y+r.y}static AddInPlace(t,r){t.x+=r.x,t.y+=r.y}static AddArray(t,r){return[t[0]+r[0],t[1]+r[1]]}static AddArrayToRef(t,r,a){a[0]=t[0]+r[0],a[1]=t[1]+r[1]}static AddArrayInPlace(t,r){t[0]+=r[0],t[1]+=r[1]}static AddScalar(t,r){return{x:t.x+r,y:t.y+r}}static AddScalarToRef(t,r,a){a.x=t.x+r,a.y=t.y+r}static AddScalarInPlace(t,r){t.x+=r,t.y+=r}static AddScalarArray(t,r){return[t[0]+r,t[1]+r]}static AddScalarArrayToRef(t,r,a){a[0]=t[0]+r,a[1]=t[1]+r}static AddScalarArrayInPlace(t,r){t[0]+=r,t[1]+=r}static Subtract(t,r){return{x:t.x-r.x,y:t.y-r.y}}static SubtractToRef(t,r,a){a.x=t.x-r.x,a.y=t.y-r.y}static SubtractInPlace(t,r){t.x-=r.x,t.y-=r.y}static SubtractArray(t,r){return[t[0]-r[0],t[1]-r[1]]}static SubtractArrayToRef(t,r,a){a[0]=t[0]-r[0],a[1]=t[1]-r[1]}static SubtractArrayInPlace(t,r){t[0]-=r[0],t[1]-=r[1]}static SubtractScalar(t,r){return{x:t.x-r,y:t.y-r}}static SubtractScalarToRef(t,r,a){a.x=t.x-r,a.y=t.y-r}static SubtractScalarInPlace(t,r){t.x-=r,t.y-=r}static SubtractScalarArray(t,r){return[t[0]-r,t[1]-r]}static SubtractScalarArrayToRef(t,r,a){a[0]=t[0]-r,a[1]=t[1]-r}static SubtractScalarArrayInPlace(t,r){t[0]-=r,t[1]-=r}static Multiply(t,r){return{x:t.x*r.x,y:t.y*r.y}}static MultiplyToRef(t,r,a){a.x=t.x*r.x,a.y=t.y*r.y}static MultiplyInPlace(t,r){t.x*=r.x,t.y*=r.y}static MultiplyArray(t,r){return[t[0]*r[0],t[1]*r[1]]}static MultiplyArrayToRef(t,r,a){a[0]=t[0]*r[0],a[1]=t[1]*r[1]}static MultiplyArrayInPlace(t,r){t[0]*=r[0],t[1]*=r[1]}static MultiplyScalar(t,r){return{x:t.x*r,y:t.y*r}}static MultiplyScalarToRef(t,r,a){a.x=t.x*r,a.y=t.y*r}static MultiplyScalarInPlace(t,r){t.x*=r,t.y*=r}static MultiplyScalarArray(t,r){return[t[0]*r,t[1]*r]}static MultiplyScalarArrayToRef(t,r,a){a[0]=t[0]*r,a[1]=t[1]*r}static MultiplyScalarArrayInPlace(t,r){t[0]*=r,t[1]*=r}static Divide(t,r){return{x:t.x/r.x,y:t.y/r.y}}static DivideToRef(t,r,a){a.x=t.x/r.x,a.y=t.y/r.y}static DivideInPlace(t,r){t.x/=r.x,t.y/=r.y}static DivideArray(t,r){return[t[0]/r[0],t[1]/r[1]]}static DivideArrayToRef(t,r,a){a[0]=t[0]/r[0],a[1]=t[1]/r[1]}static DivideArrayInPlace(t,r){t[0]/=r[0],t[1]/=r[1]}static DivideScalar(t,r){return{x:t.x/r,y:t.y/r}}static DivideScalarToRef(t,r,a){a.x=t.x/r,a.y=t.y/r}static DivideScalarInPlace(t,r){t.x/=r,t.y/=r}static DivideScalarArray(t,r){return[t[0]/r,t[1]/r]}static DivideScalarArrayToRef(t,r,a){a[0]=t[0]/r,a[1]=t[1]/r}static DivideScalarArrayInPlace(t,r){t[0]/=r,t[1]/=r}static Dot(t,r){return t.x*r.x+t.y*r.y}static DotArray(t,r){return t[0]*r[0]+t[1]*r[1]}static Length(t){return Math.sqrt(t.x*t.x+t.y*t.y)}static LengthArray(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}static Normalize(t){let r=s.Length(t);return 0===r?{x:0,y:0}:{x:t.x/r,y:t.y/r}}static NormalizeToRef(t,r){let a=s.Length(t);0===a?(r.x=0,r.y=0):(r.x=t.x/a,r.y=t.y/a)}static NormalizeInPlace(t){let r=s.Length(t);0===r?(t.x=0,t.y=0):(t.x/=r,t.y/=r)}static NormalizeArray(t){let r=s.LengthArray(t);return 0===r?[0,0]:[t[0]/r,t[1]/r]}static NormalizeArrayToRef(t,r){let a=s.LengthArray(t);0===a?(r[0]=0,r[1]=0):(r[0]=t[0]/a,r[1]=t[1]/a)}static NormalizeArrayInPlace(t){let r=s.LengthArray(t);0===r?(t[0]=0,t[1]=0):(t[0]/=r,t[1]/=r)}static Distance(t,r){return s.Length(s.Subtract(t,r))}static DistanceArray(t,r){return s.LengthArray(s.SubtractArray(t,r))}static Lerp(t,r,a){return{x:t.x+a*(r.x-t.x),y:t.y+a*(r.y-t.y)}}static LerpToRef(t,r,a,e){e.x=t.x+a*(r.x-t.x),e.y=t.y+a*(r.y-t.y)}static LerpInPlace(t,r,a){t.x+=a*(r.x-t.x),t.y+=a*(r.y-t.y)}static LerpArray(t,r,a){return[t[0]+a*(r[0]-t[0]),t[1]+a*(r[1]-t[1])]}static LerpArrayToRef(t,r,a,e){e[0]=t[0]+a*(r[0]-t[0]),e[1]=t[1]+a*(r[1]-t[1])}static LerpArrayInPlace(t,r,a){t[0]+=a*(r[0]-t[0]),t[1]+=a*(r[1]-t[1])}static Negate(t){return{x:-t.x,y:-t.y}}static NegateToRef(t,r){r.x=-t.x,r.y=-t.y}static NegateInPlace(t){t.x=-t.x,t.y=-t.y}static NegateArray(t){return[-t[0],-t[1]]}static NegateArrayToRef(t,r){r[0]=-t[0],r[1]=-t[1]}static NegateArrayInPlace(t){t[0]=-t[0],t[1]=-t[1]}static Equals(t,r){return t.x===r.x&&t.y===r.y}static EqualsArray(t,r){return t[0]===r[0]&&t[1]===r[1]}static Clone(t){return{x:t.x,y:t.y}}static CloneArray(t){return[t[0],t[1]]}static Copy(t,r){return t.x=r.x,t.y=r.y,t}static CopyArray(t,r){return t[0]=r[0],t[1]=r[1],t}static CopyFromArray(t,r){return t.x=r[0],t.y=r[1],t}static CopyIntoArray(t,r){return t[0]=r.x,t[1]=r.y,t}static ToArray(t){return[t.x,t.y]}static FromArray(t){return new s(t[0],t[1])}constructor(t,r){this.x=t,this.y=r}}class n{static Create(){return[1,0,0,0,1,0,0,0,1]}static Add(t,r){return t.map((t,a)=>t+r[a])}static AddToRef(t,r,a){t.forEach((t,e)=>a[e]=t+r[e])}static Multiply(t,r){let a=Array(9);for(let e=0;e<3;e++)for(let i=0;i<3;i++){a[3*e+i]=0;for(let y=0;y<3;y++)a[3*e+i]+=t[3*e+y]*r[3*y+i]}return a}static MultiplyToRef(t,r,a){for(let e=0;e<3;e++)for(let i=0;i<3;i++){a[3*e+i]=0;for(let y=0;y<3;y++)a[3*e+i]+=t[3*e+y]*r[3*y+i]}}static Transpose(t){return[t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8]]}static TransposeToRef(t,r){[r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8]]=[t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8]]}static Inverse(t){let r=t[0]*(t[4]*t[8]-t[7]*t[5])-t[1]*(t[3]*t[8]-t[6]*t[5])+t[2]*(t[3]*t[7]-t[6]*t[4]);if(0===r)return null;let a=1/r;return[(t[4]*t[8]-t[7]*t[5])*a,(t[2]*t[7]-t[1]*t[8])*a,(t[1]*t[5]-t[2]*t[4])*a,(t[5]*t[6]-t[3]*t[8])*a,(t[0]*t[8]-t[2]*t[6])*a,(t[2]*t[3]-t[0]*t[5])*a,(t[3]*t[7]-t[4]*t[6])*a,(t[1]*t[6]-t[0]*t[7])*a,(t[0]*t[4]-t[1]*t[3])*a]}static InverseToRef(t,r){let a=this.Inverse(t);return null!==a&&(a.forEach((t,a)=>r[a]=t),!0)}static RotationX(t){let r=Math.cos(t),a=Math.sin(t);return[1,0,0,0,r,-a,0,a,r]}static RotationY(t){let r=Math.cos(t),a=Math.sin(t);return[r,0,a,0,1,0,-a,0,r]}static RotationZ(t){let r=Math.cos(t),a=Math.sin(t);return[r,-a,0,a,r,0,0,0,1]}static Scaling(t,r,a){return[t,0,0,0,r,0,0,0,a]}static Transform(t,r,a){return[1,0,0,0,1,0,t,r,a]}static ApplyMatrix(t,r){return{x:t[0]*r.x+t[1]*r.y+t[2]*r.z,y:t[3]*r.x+t[4]*r.y+t[5]*r.z,z:t[6]*r.x+t[7]*r.y+t[8]*r.z}}static ApplyMatrixArray(t,r){return[t[0]*r[0]+t[1]*r[1]+t[2]*r[2],t[3]*r[0]+t[4]*r[1]+t[5]*r[2],t[6]*r[0]+t[7]*r[1]+t[8]*r[2]]}}let l=t=>t>=0?2*t:-2*t-1,x=(t,r)=>(t+r)*(t+r+1)/2+r;class u{static Create(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return new u(t,r,a)}static HashXYZ(t,r,a){let e=l(t),i=l(r),y=l(a),c=x(e,i);return x(c,y)}static Hash(t){return this.HashXYZ(t.x,t.y,t.z)}static HashArray(t){return this.HashXYZ(t[0],t[1],t[2])}static ApplyMatrix(t,r){return n.ApplyMatrix(t,r)}static ApplyMatrixArray(t,r){return n.ApplyMatrixArray(t,r)}static RotateAroundPivot(t,r,a){let e={x:r.x-a.x,y:r.y-a.y,z:r.z-a.z},i=u.ApplyMatrix(t,e);return{x:i.x+a.x,y:i.y+a.y,z:i.z+a.z}}static RotateAroundPivotArray(t,r,a){let e=[r[0]-a[0],r[1]-a[1],r[2]-a[2]],i=u.ApplyMatrixArray(t,e);return[i[0]+a[0],i[1]+a[1],i[2]+a[2]]}static FloorInPlace(t){return t.x=Math.floor(t.x),t.y=Math.floor(t.y),t.z=Math.floor(t.z),t}static FloorArrayInPlace(t){return t[0]=Math.floor(t[0]),t[1]=Math.floor(t[1]),t[2]=Math.floor(t[2]),t}static RoundArrayInPlaceToScalar(t,r){return t[0]=Math.round(t[0]*r)/r,t[1]=Math.round(t[1]*r)/r,t[2]=Math.round(t[2]*r)/r,t}static Add(t,r){return{x:t.x+r.x,y:t.y+r.y,z:t.z+r.z}}static AddToRef(t,r,a){a.x=t.x+r.x,a.y=t.y+r.y,a.z=t.z+r.z}static AddInPlace(t,r){t.x+=r.x,t.y+=r.y,t.z+=r.z}static AddArray(t,r){return[t[0]+r[0],t[1]+r[1],t[2]+r[2]]}static AddArrayToRef(t,r,a){a[0]=t[0]+r[0],a[1]=t[1]+r[1],a[2]=t[2]+r[2]}static AddArrayInPlace(t,r){t[0]+=r[0],t[1]+=r[1],t[2]+=r[2]}static AddScalar(t,r){return{x:t.x+r,y:t.y+r,z:t.z+r}}static AddScalarToRef(t,r,a){a.x=t.x+r,a.y=t.y+r,a.z=t.z+r}static AddScalarInPlace(t,r){t.x+=r,t.y+=r,t.z+=r}static AddScalarArray(t,r){return[t[0]+r,t[1]+r,t[2]+r]}static AddScalarArrayToRef(t,r,a){a[0]=t[0]+r,a[1]=t[1]+r,a[2]=t[2]+r}static AddScalarArrayInPlace(t,r){t[0]+=r,t[1]+=r,t[2]+=r}static Subtract(t,r){return{x:t.x-r.x,y:t.y-r.y,z:t.z-r.z}}static SubtractToRef(t,r,a){a.x=t.x-r.x,a.y=t.y-r.y,a.z=t.z-r.z}static SubtractInPlace(t,r){return t.x-=r.x,t.y-=r.y,t.z-=r.z,t}static SubtractArray(t,r){return[t[0]-r[0],t[1]-r[1],t[2]-r[2]]}static SubtractArrayToRef(t,r,a){a[0]=t[0]-r[0],a[1]=t[1]-r[1],a[2]=t[2]-r[2]}static SubtractArrayInPlace(t,r){t[0]-=r[0],t[1]-=r[1],t[2]-=r[2]}static SubtractScalar(t,r){return{x:t.x-r,y:t.y-r,z:t.z-r}}static SubtractScalarToRef(t,r,a){a.x=t.x-r,a.y=t.y-r,a.z=t.z-r}static SubtractScalarInPlace(t,r){t.x-=r,t.y-=r,t.z-=r}static SubtractScalarArray(t,r){return[t[0]-r,t[1]-r,t[2]-r]}static SubtractScalarArrayToRef(t,r,a){a[0]=t[0]-r,a[1]=t[1]-r,a[2]=t[2]-r}static SubtractScalarArrayInPlace(t,r){t[0]-=r,t[1]-=r,t[2]-=r}static Multiply(t,r){return{x:t.x*r.x,y:t.y*r.y,z:t.z*r.z}}static MultiplyToRef(t,r,a){a.x=t.x*r.x,a.y=t.y*r.y,a.z=t.z*r.z}static MultiplyInPlace(t,r){t.x*=r.x,t.y*=r.y,t.z*=r.z}static MultiplyArray(t,r){return[t[0]*r[0],t[1]*r[1],t[2]*r[2]]}static MultiplyArrayToRef(t,r,a){a[0]=t[0]*r[0],a[1]=t[1]*r[1],a[2]=t[2]*r[2]}static MultiplyArrayInPlace(t,r){t[0]*=r[0],t[1]*=r[1],t[2]*=r[2]}static MultiplyScalar(t,r){return{x:t.x*r,y:t.y*r,z:t.z*r}}static MultiplyScalarToRef(t,r,a){a.x=t.x*r,a.y=t.y*r,a.z=t.z*r}static MultiplyScalarInPlace(t,r){t.x*=r,t.y*=r,t.z*=r}static MultiplyScalarArray(t,r){return[t[0]*r,t[1]*r,t[2]*r]}static MultiplyScalarArrayToRef(t,r,a){a[0]=t[0]*r,a[1]=t[1]*r,a[2]=t[2]*r}static MultiplyScalarArrayInPlace(t,r){t[0]*=r,t[1]*=r,t[2]*=r}static Divide(t,r){return{x:t.x/r.x,y:t.y/r.y,z:t.z/r.z}}static DivideToRef(t,r,a){a.x=t.x/r.x,a.y=t.y/r.y,a.z=t.z/r.z}static DivideInPlace(t,r){return t.x/=r.x,t.y/=r.y,t.z/=r.z,t}static DivideArray(t,r){return[t[0]/r[0],t[1]/r[1],t[2]/r[2]]}static DivideArrayToRef(t,r,a){a[0]=t[0]/r[0],a[1]=t[1]/r[1],a[2]=t[2]/r[2]}static DivideArrayInPlace(t,r){t[0]/=r[0],t[1]/=r[1],t[2]/=r[2]}static DivideScalar(t,r){return{x:t.x/r,y:t.y/r,z:t.z/r}}static DivideScalarToRef(t,r,a){a.x=t.x/r,a.y=t.y/r,a.z=t.z/r}static DivideScalarInPlace(t,r){t.x/=r,t.y/=r,t.z/=r}static DivideScalarArray(t,r){return[t[0]/r,t[1]/r,t[2]/r]}static DivideScalarArrayToRef(t,r,a){a[0]=t[0]/r,a[1]=t[1]/r,a[2]=t[2]/r}static DivideScalarArrayInPlace(t,r){t[0]/=r,t[1]/=r,t[2]/=r}static Dot(t,r){return t.x*r.x+t.y*r.y+t.z*r.z}static DotArray(t,r){return t[0]*r[0]+t[1]*r[1]+t[2]*r[2]}static Cross(t,r){return{x:t.y*r.z-t.z*r.y,y:t.z*r.x-t.x*r.z,z:t.x*r.y-t.y*r.x}}static CrossToRef(t,r,a){a.x=t.y*r.z-t.z*r.y,a.y=t.z*r.x-t.x*r.z,a.z=t.x*r.y-t.y*r.x}static CrossInPlace(t,r){let a=t.y*r.z-t.z*r.y,e=t.z*r.x-t.x*r.z,i=t.x*r.y-t.y*r.x;t.x=a,t.y=e,t.z=i}static CrossArray(t,r){return[t[1]*r[2]-t[2]*r[1],t[2]*r[0]-t[0]*r[2],t[0]*r[1]-t[1]*r[0]]}static CrossArrayToRef(t,r,a){a[0]=t[1]*r[2]-t[2]*r[1],a[1]=t[2]*r[0]-t[0]*r[2],a[2]=t[0]*r[1]-t[1]*r[0]}static CrossArrayInPlace(t,r){let a=t[1]*r[2]-t[2]*r[1],e=t[2]*r[0]-t[0]*r[2],i=t[0]*r[1]-t[1]*r[0];t[0]=a,t[1]=e,t[2]=i}static Length(t){return Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z)}static LengthArray(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}static Normalize(t){let r=u.Length(t);return 0===r?{x:0,y:0,z:0}:{x:t.x/r,y:t.y/r,z:t.z/r}}static NormalizeToRef(t,r){let a=u.Length(t);0===a?(r.x=0,r.y=0,r.z=0):(r.x=t.x/a,r.y=t.y/a,r.z=t.z/a)}static NormalizeInPlace(t){let r=u.Length(t);0===r?(t.x=0,t.y=0,t.z=0):(t.x/=r,t.y/=r,t.z/=r)}static NormalizeArray(t){let r=u.LengthArray(t);return 0===r?[0,0,0]:[t[0]/r,t[1]/r,t[2]/r]}static NormalizeArrayToRef(t,r){let a=u.LengthArray(t);0===a?(r[0]=0,r[1]=0,r[2]=0):(r[0]=t[0]/a,r[1]=t[1]/a,r[2]=t[2]/a)}static NormalizeArrayInPlace(t){let r=u.LengthArray(t);0===r?(t[0]=0,t[1]=0,t[2]=0):(t[0]/=r,t[1]/=r,t[2]/=r)}static Distance(t,r){return u.Length(u.Subtract(t,r))}static DistanceArray(t,r){return u.LengthArray(u.SubtractArray(t,r))}static Lerp(t,r,a){return{x:t.x+a*(r.x-t.x),y:t.y+a*(r.y-t.y),z:t.z+a*(r.z-t.z)}}static LerpToRef(t,r,a,e){e.x=t.x+a*(r.x-t.x),e.y=t.y+a*(r.y-t.y),e.z=t.z+a*(r.z-t.z)}static LerpInPlace(t,r,a){t.x+=a*(r.x-t.x),t.y+=a*(r.y-t.y),t.z+=a*(r.z-t.z)}static LerpArray(t,r,a){return[t[0]+a*(r[0]-t[0]),t[1]+a*(r[1]-t[1]),t[2]+a*(r[2]-t[2])]}static LerpArrayToRef(t,r,a,e){e[0]=t[0]+a*(r[0]-t[0]),e[1]=t[1]+a*(r[1]-t[1]),e[2]=t[2]+a*(r[2]-t[2])}static LerpArrayInPlace(t,r,a){t[0]+=a*(r[0]-t[0]),t[1]+=a*(r[1]-t[1]),t[2]+=a*(r[2]-t[2])}static Negate(t){return{x:-t.x,y:-t.y,z:-t.z}}static NegateToRef(t,r){r.x=-t.x,r.y=-t.y,r.z=-t.z}static NegateInPlace(t){t.x=-t.x,t.y=-t.y,t.z=-t.z}static NegateArray(t){return[-t[0],-t[1],-t[2]]}static NegateArrayToRef(t,r){r[0]=-t[0],r[1]=-t[1],r[2]=-t[2]}static NegateArrayInPlace(t){t[0]=-t[0],t[1]=-t[1],t[2]=-t[2]}static Equals(t,r){return t.x===r.x&&t.y===r.y&&t.z===r.z}static EqualsArray(t,r){return t[0]===r[0]&&t[1]===r[1]&&t[2]===r[2]}static Clone(t){return{x:t.x,y:t.y,z:t.z}}static CloneArray(t){return[t[0],t[1],t[2]]}static Copy(t,r){return t.x=r.x,t.y=r.y,t.z=r.z,t}static CopyArray(t,r){return t[0]=r[0],t[1]=r[1],t[2]=r[2],t}static CopyFromArray(t,r){return t.x=r[0],t.y=r[1],t.z=r[2],t}static CopyIntoArray(t,r){return t[0]=r.x,t[1]=r.y,t[2]=r.z,t}static ToArray(t){return[t.x,t.y,t.z]}static FromArray(t){return new u(t[0],t[1],t[2])}constructor(t,r,a){this.x=t,this.y=r,this.z=a}}class o{getBounds(){return this.bounds}static GetXYOrder(){return new o((t,r)=>t[0]+t[1]*r[0],(t,r,a)=>{a[1]=Math.floor(t/r[0]),a[0]=Math.floor(t%r[0])})}get size(){return this.bounds[0]*this.bounds[1]}getIndex(t){return this._getIndex(t,this.bounds)}getIndexVec2Array(t){return this.position[0]=t[0],this.position[1]=t[1],this._getIndex(this.position,this.bounds)}getIndexXY(t,r){return this.position[0]=t,this.position[1]=r,this._getIndex(this.position,this.bounds)}getXY(t){return this._getXY(t,this.bounds,this.output),this.output}setBounds(t,r){this.bounds[0]=t,this.bounds[1]=r}constructor(t,r){this.output=[0,0],this._getIndex=t,this._getXY=r,this.position=[0,0],this.bounds=[1,1]}}(y=e||(e={})).North="north",y.South="south",y.West="west",y.East="east",y.NorthEast="north-east",y.NorthWest="north-west",y.SouthEast="south-east",y.SouthWest="south-west",(c=i||(i={}))[c.North=0]="North",c[c.NorthEast=Math.PI/4]="NorthEast",c[c.East=Math.PI/2]="East",c[c.SouthEast=3*Math.PI/4]="SouthEast",c[c.South=Math.PI]="South",c[c.SouthWest=5*Math.PI/4]="SouthWest",c[c.West=3*Math.PI/2]="West",c[c.NorthWest=7*Math.PI/4]="NorthWest",e.North,i.North,e.South,i.South,e.West,i.West,e.East,i.East,e.NorthEast,i.NorthEast,e.NorthWest,i.NorthWest,e.SouthEast,i.SouthEast,e.SouthWest,i.SouthWest}}]);