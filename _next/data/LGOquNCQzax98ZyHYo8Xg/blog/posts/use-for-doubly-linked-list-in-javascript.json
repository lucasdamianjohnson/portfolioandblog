{"pageProps":{"data":{"title":"Using A Doubly Linked List In JavaScript","description":"Use case for a doubly-linked list in JavaScript.","date":"2021-11-10","banner":" { \"src\" : \"/images/blog/nodedisplay.png\", \"alt\":\"sup\" } ","id":"use-for-doubly-linked-list-in-javascript"},"content":"\r\nWhen I was a computer science student my two favorite classes were databases and data structures. Since starting my professional work as a web programmer I have not found my use cases for the data structures I learned in college until recently. So, today I want to talk about the data structure known as a Doubly Linked List and show you a use case for it that I have recently found.\r\n\r\nI will not go into the heavy implementation details of setting up a Doubly Linked List in JavaScript. However, I do have a TypeScript class and interface available for you to look at it if you want to see the full implementation details. It however is a Doubly Linked List mixed with a Map. I call it a Doubly Linked ID List.\r\n\r\n# What is a Doubly Linked List?\r\n\r\nWe can conceive a doubly-linked list in JavaScript to be an array or map of objects that have a reference to the object that is before and after. In that way, it preserver’s its order.\r\n\r\nNow in the example class, I provided the before and after references are actually ids used in the map of objects. I do not use a direct reference for the object. Either way, it will work the same but I will get into that more later.\r\n\r\n# What is it good for?\r\n\r\nA doubly linked list excels at a couple of things. Number one would be the time complexity of inserting and taking things out of it. With a normal array if you want to add something to the front you have to move that entire array forward. With a doubly-linked list, you just change the references to the before and after objects for the objects that you want to insert in-between. Here you see the time complexity compared:\r\n\r\n\r\n| Data Structures       | Insert | Insert | Insert | Insert |\r\n| --------------------- | ------ | ------ | ------ | ------ |\r\n| Doubly Linked ID List | O(1)   | O(1)   | O(1)   | O(n)   |\r\n| Doubly Linked List    | O(1)   | O(1)   | O(n)   | O(n)   |\r\n| Normal Array          | O(n)   | O(n)   | O(1)   | O(n)   |\r\n\r\n\r\nNow if you are dealing with small data sets a doubly linked list may be a bit much. But if you are dealing with thousands or millions of objects then it becomes indicative to come up with a solution that is fast especially if you have to do a lot of inserting and deleting.\r\n\r\n# Real Example Use Case\r\n\r\nSo, I am currently developing a level creator program using TypeScript, Babylon.Js, and Electron. It allows you to place thousands upon thousands of models in a single scene and have the ability to edit each individually and in a group. On the left-hand display of the window, there is a display with all the nodes in the scene. The user can scroll through all the nodes, edit them, delete them, and drag n’ drop them to new locations and inside groups.\r\n\r\nWell, in this case, if we used a normal array and the user had something like 10,000 models in the scene we would have to move all other 9,999 models in the array to match the new arrangement. But with a doubly-linked list, it becomes extremely fast. We just have to remove the object from the current list by changing its before and after references as well it’s surrounding objects and then either discard it or put it in another part of the list by once again changing its new surrounding objects before and after references as well as it’s own. So, It’s about 8 operations instead of 9k.\r\n\r\n# Conclusion\r\n\r\nYour app may benefit from using a doubly-linked list or some variant of it if you are doing a bunch of inserting and deleting on an array and need to preserve its order. They are easy to implement in JavaScript and can be expanded with more helpful functions such as my example class shows. They are not the solution for everything but for very specific things they are amazing.\r\n\r\n## Full Doubly Linked ID List Implementation\r\n\r\n```ts\r\nexport type DoubleLinkedIDListNode<T> = {\r\n  data: T | false;\r\n  prev: string | false;\r\n  next: string | false;\r\n};\r\n\r\nexport type DoubleLinkedIDListNodes<T> = Record<\r\n  string,\r\n  DoubleLinkedIDListNode<T>\r\n>;\r\nexport type DoubleLinkedIDConstructor<T> =\r\n  new () => DoubleLinkedIDListInterface<T>;\r\n/**# Double Linked ID List\r\n * ---\r\n * A doubly linked list mixed with a map.\r\n *\r\n *\r\n */\r\nexport interface DoubleLinkedIDListInterface<T> {\r\n  size: number;\r\n  nodes: DoubleLinkedIDListNodes<T>;\r\n\r\n  keys(): string[];\r\n  /**# Move Node Before Other\r\n   * ---\r\n   * Move a node to be the previous node of the static node.\r\n   * @param staticNodeId\r\n   * @param nodeMovingId\r\n   */\r\n  moveNodeBeforeOther(staticNodeId: string, nodeMovingId: string): void;\r\n  /**# Move Node After Other\r\n   * ---\r\n   * Move a node to be the next node of the static node.\r\n   * @param staticNodeId\r\n   * @param nodeMovingId\r\n   */\r\n  moveNodeAfterOther(staticNodeId: string, nodeMovingId: string): void;\r\n  /**# Append\r\n   * ---\r\n   * Move node to the bottom of the list.\r\n   * @param id\r\n   */\r\n  append(id: string): void;\r\n  /**# Prepend\r\n   * ---\r\n   * Move node to the top of the list.\r\n   * @param id\r\n   */\r\n  prepend(id: string): void;\r\n  /**# Insert Before\r\n   * ---\r\n   * Create a new node and insert it before the given node.\r\n   * @param insertAtId\r\n   * @param id\r\n   * @param Data\r\n   */\r\n  insertBefore(insertAtId: string, id: string, Data: T): void;\r\n  /**# Insert After\r\n   * ---\r\n   * Create a new node and insert it after the given node.\r\n   * @param insertAtId\r\n   * @param id\r\n   * @param Data\r\n   */\r\n  insertAfter(insertAtId: string, id: string, Data: T): void;\r\n  /**# Append New\r\n   * ---\r\n   * Create a new node and insert at the end of the list.\r\n   * @param id\r\n   * @param Data\r\n   */\r\n  appendNew(id: string, Data: T): void;\r\n  /**# Prepend New\r\n   * ---\r\n   * Create a new node and insert at the start of the list.\r\n   * @param id\r\n   * @param Data\r\n   */\r\n  prependNew(id: string, Data: T): void;\r\n  /**# Pop\r\n   * ---\r\n   * Take a node out from the list and reconfigure it's prev and next nodes to point to each other.\r\n   * @param id\r\n   */\r\n  pop(id: string): DoubleLinkedIDListNode<T>;\r\n  /**# Remove\r\n   * ---\r\n   * Deletes a node from it's list and updates it's previous and next nodes.\r\n   * @param id\r\n   */\r\n  remove(id: string): void;\r\n  removeAll(): void;\r\n\r\n  getValue(id: string): T | false;\r\n  setValue(id: string, data: T): void;\r\n\r\n  traverseWithFuncForward(func: (key: string, data: T) => any): void;\r\n  traverseWithFuncBackward(func: (key: string, data: T) => any): void;\r\n  traverseIDsForward(): IteratorResult<string>;\r\n  traverseValuesForward(): IteratorResult<T | false>;\r\n  traverseKeyValuesForward(): IteratorResult<{ key: string; value: T | false }>;\r\n  traverseIDsBackward(): IteratorResult<string>;\r\n  traverseValuesBackward(): IteratorResult<T | false>;\r\n  traverseKeyValuesBackward(): IteratorResult<{\r\n    key: string;\r\n    value: T | false;\r\n  }>;\r\n\r\n  getNextKVP(id: string): { key: string; value: T | false } | false;\r\n  getPrevKVP(id: string): { key: string; value: T | false } | false;\r\n  getNextID(id: string): string | false;\r\n  getPrevID(id: string): string | false;\r\n\r\n  resetTraverse(): void;\r\n  exists(id: string): boolean;\r\n  getKVP(id: string): { key: string; value: T | false } | false;\r\n  getFirstID(): string;\r\n  getLastID(): string;\r\n\r\n  isBefore(startId: string, idLookingFor: string): boolean;\r\n  isAfter(startId: string, idLookingFor: string): boolean;\r\n}\r\n\r\nexport class DounleLinkedIDList<T> implements DoubleLinkedIDListInterface<T> {\r\n  size: number = 0;\r\n  head: DoubleLinkedIDListNode<T>;\r\n  tail: DoubleLinkedIDListNode<T>;\r\n  nodes: DoubleLinkedIDListNodes<T> = {};\r\n\r\n  currentNodeID: string;\r\n  _currentIteratorFowardData: T | false;\r\n  _currentIteratorBackwardData: T | false;\r\n  _currentIteratorForwardId = \"head\";\r\n  _currentIteratorBackwardId = \"tail\";\r\n\r\n  constructor() {\r\n    this.head = {\r\n      data: false,\r\n      next: \"tail\",\r\n      prev: false,\r\n    };\r\n    this.tail = {\r\n      data: false,\r\n      next: false,\r\n      prev: \"head\",\r\n    };\r\n    this.nodes[\"head\"] = this.head;\r\n    this.nodes[\"tail\"] = this.tail;\r\n  }\r\n\r\n  keys() {\r\n    const keys = Object.keys(this.nodes);\r\n    const headIndex = keys.indexOf(\"head\");\r\n    keys.splice(headIndex, 1);\r\n    const tailIndex = keys.indexOf(\"tail\");\r\n    keys.splice(tailIndex, 1);\r\n    return keys;\r\n  }\r\n\r\n  getFirstID() {\r\n    if (this.head.next == \"tail\") return \"\";\r\n    return <string>this.head.next;\r\n  }\r\n\r\n  getLastID() {\r\n    if (this.tail.prev == \"head\") return \"\";\r\n    return <string>this.tail.prev;\r\n  }\r\n\r\n  insertBefore(insertAtId: string, id: string, Data: T) {\r\n    if (!this.exists(insertAtId)) {\r\n      throw new Error(`${insertAtId} does not exist.`);\r\n    }\r\n    if (this.exists(id)) {\r\n      throw new Error(`${id} already exist.`);\r\n    }\r\n    const insertBeforerNode = this.nodes[insertAtId];\r\n    if (!insertBeforerNode.prev) return;\r\n    const beforeNodeID = insertBeforerNode.prev;\r\n    const beforeNode = this.nodes[beforeNodeID];\r\n    const newNode: DoubleLinkedIDListNode<T> = {\r\n      data: Data,\r\n      prev: beforeNodeID,\r\n      next: insertAtId,\r\n    };\r\n    beforeNode.next = id;\r\n    insertBeforerNode.prev = id;\r\n    this.nodes[id] = newNode;\r\n    this.size++;\r\n  }\r\n  insertAfter(insertAtId: string, id: string, Data: T) {\r\n    if (!this.exists(insertAtId)) {\r\n      throw new Error(`${insertAtId} does not exist.`);\r\n    }\r\n    if (this.exists(id)) {\r\n      throw new Error(`${id} already exist.`);\r\n    }\r\n    const insertAfterNode = this.nodes[insertAtId];\r\n    if (!insertAfterNode.next) return;\r\n    const nextNodeID = insertAfterNode.next;\r\n    const nextNode = this.nodes[nextNodeID];\r\n    const newNode: DoubleLinkedIDListNode<T> = {\r\n      data: Data,\r\n      prev: insertAtId,\r\n      next: nextNodeID,\r\n    };\r\n    nextNode.prev = id;\r\n    insertAfterNode.next = id;\r\n    this.nodes[id] = newNode;\r\n    this.size++;\r\n    return this.nodes[id];\r\n  }\r\n\r\n  moveNodeBeforeOther(staticNodeId: string, nodeMovingId: string) {\r\n    if (!this.exists(staticNodeId)) {\r\n      throw new Error(`${staticNodeId} does not exist.`);\r\n    }\r\n    if (!this.exists(nodeMovingId)) {\r\n      throw new Error(`${nodeMovingId} does not exist.`);\r\n    }\r\n    const insertBeforerNode = this.nodes[staticNodeId];\r\n    if (!insertBeforerNode.prev) return;\r\n    const beforeNodeID = insertBeforerNode.prev;\r\n    const beforeNode = this.nodes[beforeNodeID];\r\n\r\n    const nodeMoving = this.pop(nodeMovingId);\r\n\r\n    beforeNode.next = nodeMovingId;\r\n\r\n    nodeMoving.prev = beforeNodeID;\r\n    nodeMoving.next = staticNodeId;\r\n\r\n    insertBeforerNode.prev = nodeMovingId;\r\n  }\r\n  moveNodeAfterOther(staticNodeId: string, nodeMovingId: string) {\r\n    if (!this.exists(staticNodeId)) {\r\n      throw new Error(`${staticNodeId} does not exist.`);\r\n    }\r\n    if (!this.exists(nodeMovingId)) {\r\n      throw new Error(`${nodeMovingId} does not exist.`);\r\n    }\r\n    const insertAfterNode = this.nodes[staticNodeId];\r\n    if (!insertAfterNode.next) return;\r\n    const afterNodeID = insertAfterNode.next;\r\n    const afterNode = this.nodes[afterNodeID];\r\n\r\n    const nodeMoving = this.pop(nodeMovingId);\r\n    insertAfterNode.next = nodeMovingId;\r\n    nodeMoving.prev = staticNodeId;\r\n    nodeMoving.next = afterNodeID;\r\n    afterNode.prev = nodeMovingId;\r\n  }\r\n  pop(id: string): DoubleLinkedIDListNode<T> {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    const nodeMoving = this.nodes[id];\r\n    const nodeMovingBeforeId = nodeMoving.prev;\r\n    const nodeMovingAfterId = nodeMoving.next;\r\n    if (!nodeMovingBeforeId && !nodeMovingAfterId) {\r\n      return nodeMoving;\r\n    }\r\n    const nodeMovingBefore = this.nodes[<string>nodeMovingBeforeId];\r\n    const nodeMovingAfter = this.nodes[<string>nodeMovingAfterId];\r\n    nodeMovingBefore.next = nodeMovingAfterId;\r\n    nodeMovingAfter.prev = nodeMovingBeforeId;\r\n    return nodeMoving;\r\n  }\r\n  remove(id: string): void {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    this.pop(id);\r\n    //@ts-ignore\r\n    this.nodes[id] = undefined;\r\n    delete this.nodes[id];\r\n    this.size--;\r\n  }\r\n  removeAll() {\r\n    //@ts-ignore\r\n    this.nodes = undefined;\r\n    this.nodes = {};\r\n    this.size = 0;\r\n    this.head.next = \"tail\";\r\n    this.tail.prev = \"head\";\r\n    this._currentIteratorBackwardData = false;\r\n    this._currentIteratorFowardData = false;\r\n    this._currentIteratorForwardId = \"head\";\r\n    this._currentIteratorBackwardId = \"tail\";\r\n  }\r\n\r\n  append(id: string) {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    if (!this.tail.prev) return;\r\n    if (this.tail.prev == \"head\") {\r\n      this.head.next = id;\r\n    }\r\n    const prevNodeId = this.tail.prev;\r\n    const prevNode = this.nodes[prevNodeId];\r\n    prevNode.next = id;\r\n    this.tail.prev = id;\r\n    const movingNode = this.pop(id);\r\n    movingNode.prev = prevNodeId;\r\n    movingNode.next = \"tail\";\r\n  }\r\n  prepend(id: string) {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    if (!this.head.next) return;\r\n    if (this.head.next == \"tail\") {\r\n      this.tail.prev = id;\r\n    }\r\n    const nextNodeId = this.head.next;\r\n    const nextNode = this.nodes[nextNodeId];\r\n    nextNode.prev = id;\r\n    this.head.next = id;\r\n    const movingNode = this.pop(id);\r\n    movingNode.prev = \"head\";\r\n    movingNode.next = nextNodeId;\r\n  }\r\n\r\n  appendNew(id: string, Data: T) {\r\n    if (this.exists(id)) {\r\n      throw new Error(`${id} already exist.`);\r\n    }\r\n    if (!this.tail.prev) return;\r\n    if (this.tail.prev == \"head\") {\r\n      this.head.next = id;\r\n    }\r\n\r\n    const bottomNodeId = this.tail.prev;\r\n    const newNode: DoubleLinkedIDListNode<T> = {\r\n      data: Data,\r\n      prev: bottomNodeId,\r\n      next: \"tail\",\r\n    };\r\n    this.nodes[id] = newNode;\r\n    this.nodes[bottomNodeId].next = id;\r\n    this.tail.prev = id;\r\n    this.size++;\r\n  }\r\n  prependNew(id: string, Data: T) {\r\n    if (this.exists(id)) {\r\n      throw new Error(`${id} already exist.`);\r\n    }\r\n    if (!this.head.next) return;\r\n    if (this.head.next == \"tail\") {\r\n      this.tail.prev = id;\r\n    }\r\n    const topNodeId = this.head.next;\r\n    const newNode: DoubleLinkedIDListNode<T> = {\r\n      data: Data,\r\n      prev: \"head\",\r\n      next: topNodeId,\r\n    };\r\n    this.nodes[id] = newNode;\r\n    this.nodes[topNodeId].prev = id;\r\n    this.head.next = id;\r\n    this.size++;\r\n  }\r\n\r\n  getValue(id: string) {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    return this.nodes[id].data;\r\n  }\r\n  setValue(id: string, data: T) {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    this.nodes[id].data = data;\r\n  }\r\n\r\n  traverseWithFuncForward(func: (key: string, data: T) => any) {\r\n    let data: IteratorResult<{ key: string; value: T | false }>;\r\n    data = this.traverseKeyValuesForward();\r\n    while (!data.done) {\r\n      func(data.value.key, <T>data.value.value);\r\n\r\n      data = this.traverseKeyValuesForward();\r\n    }\r\n  }\r\n\r\n  traverseWithFuncBackward(func: (key: string, data: T) => any) {\r\n    let data: IteratorResult<{ key: string; value: T | false }>;\r\n    data = this.traverseKeyValuesBackward();\r\n    while (!data.done) {\r\n      func(data.value.key, <T>data.value.value);\r\n\r\n      data = this.traverseKeyValuesForward();\r\n    }\r\n  }\r\n\r\n  resetTraverse() {\r\n    this._currentIteratorForwardId = \"head\";\r\n    this._currentIteratorBackwardId = \"tail\";\r\n  }\r\n\r\n  traverseIDsForward(): IteratorResult<string> {\r\n    let done = false;\r\n    if (this.nodes[this._currentIteratorForwardId].next == \"tail\") {\r\n      done = true;\r\n      this._currentIteratorForwardId = \"head\";\r\n    } else {\r\n      this._currentIteratorForwardId = <string>(\r\n        this.nodes[this._currentIteratorForwardId].next\r\n      );\r\n      this._currentIteratorFowardData =\r\n        this.nodes[this._currentIteratorForwardId].data;\r\n    }\r\n    return {\r\n      done: done,\r\n      value: this._currentIteratorForwardId,\r\n    };\r\n  }\r\n  traverseValuesForward(): IteratorResult<T | false> {\r\n    let done = false;\r\n    if (this.nodes[this._currentIteratorForwardId].next == \"tail\") {\r\n      done = true;\r\n      this._currentIteratorForwardId = \"head\";\r\n    } else {\r\n      this._currentIteratorForwardId = <string>(\r\n        this.nodes[this._currentIteratorForwardId].next\r\n      );\r\n      this._currentIteratorFowardData =\r\n        this.nodes[this._currentIteratorForwardId].data;\r\n    }\r\n    return {\r\n      done: done,\r\n      value: this._currentIteratorFowardData,\r\n    };\r\n  }\r\n  traverseKeyValuesForward(): IteratorResult<{\r\n    key: string;\r\n    value: T | false;\r\n  }> {\r\n    let done = false;\r\n    if (this.nodes[this._currentIteratorForwardId].next == \"tail\") {\r\n      done = true;\r\n      this._currentIteratorForwardId = \"head\";\r\n    } else {\r\n      this._currentIteratorForwardId = <string>(\r\n        this.nodes[this._currentIteratorForwardId].next\r\n      );\r\n      this._currentIteratorFowardData =\r\n        this.nodes[this._currentIteratorForwardId].data;\r\n    }\r\n    return {\r\n      done: done,\r\n      value: {\r\n        key: this._currentIteratorForwardId,\r\n        value: this._currentIteratorFowardData,\r\n      },\r\n    };\r\n  }\r\n\r\n  traverseIDsBackward(): IteratorResult<string> {\r\n    let done = false;\r\n    if (this.nodes[this._currentIteratorBackwardId].prev == \"head\") {\r\n      done = true;\r\n      this._currentIteratorBackwardId = \"tail\";\r\n    } else {\r\n      this._currentIteratorBackwardId = <string>(\r\n        this.nodes[this._currentIteratorBackwardId].prev\r\n      );\r\n    }\r\n    return {\r\n      done: done,\r\n      value: this._currentIteratorBackwardId,\r\n    };\r\n  }\r\n  traverseValuesBackward(): IteratorResult<T | false> {\r\n    let done = false;\r\n    if (this.nodes[this._currentIteratorBackwardId].prev == \"head\") {\r\n      done = true;\r\n      this._currentIteratorBackwardId = \"tail\";\r\n    } else {\r\n      this._currentIteratorBackwardId = <string>(\r\n        this.nodes[this._currentIteratorBackwardId].prev\r\n      );\r\n      this._currentIteratorBackwardData =\r\n        this.nodes[this._currentIteratorBackwardId].data;\r\n    }\r\n    return {\r\n      done: done,\r\n      value: this._currentIteratorBackwardData,\r\n    };\r\n  }\r\n  traverseKeyValuesBackward(): IteratorResult<{\r\n    key: string;\r\n    value: T | false;\r\n  }> {\r\n    let done = false;\r\n    if (this.nodes[this._currentIteratorBackwardId].prev == \"head\") {\r\n      done = true;\r\n      this._currentIteratorBackwardId = \"tail\";\r\n    } else {\r\n      this._currentIteratorBackwardId = <string>(\r\n        this.nodes[this._currentIteratorBackwardId].prev\r\n      );\r\n      this._currentIteratorBackwardData =\r\n        this.nodes[this._currentIteratorBackwardId].data;\r\n    }\r\n    return {\r\n      done: done,\r\n      value: {\r\n        key: this._currentIteratorBackwardId,\r\n        value: this._currentIteratorBackwardData,\r\n      },\r\n    };\r\n  }\r\n\r\n  exists(id: string) {\r\n    if (this.nodes[id] === undefined) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  getKVP(id: string): { key: string; value: T | false } | false {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    const node = this.nodes[id];\r\n    if (!node) {\r\n      return false;\r\n    }\r\n    return { key: id, value: node.data };\r\n  }\r\n\r\n  getNextKVP(id: string): { key: string; value: T | false } | false {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    if (!this.nodes[id]) {\r\n      throw new Error(`${id} does not exist`);\r\n    }\r\n    const node = this.nodes[id];\r\n    if (!node.next || node.next == \"tail\") return false;\r\n    const nextNode = this.nodes[node.next];\r\n    return { key: node.next, value: nextNode.data };\r\n  }\r\n\r\n  getPrevKVP(id: string): { key: string; value: T | false } | false {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    const node = this.nodes[id];\r\n    if (!node.prev || node.prev == \"head\") return false;\r\n    const nextNode = this.nodes[node.prev];\r\n    return { key: node.prev, value: nextNode.data };\r\n  }\r\n\r\n  getNextID(id: string): string | false {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    const node = this.nodes[id];\r\n    if (!node.next || node.next == \"tail\") return false;\r\n    return node.next;\r\n  }\r\n  getPrevID(id: string): string | false {\r\n    if (!this.exists(id)) {\r\n      throw new Error(`${id} does not exist.`);\r\n    }\r\n    const node = this.nodes[id];\r\n    if (!node.prev || node.prev == \"head\") return false;\r\n    return node.prev;\r\n  }\r\n\r\n  isBefore(startId: string, idLookingFor: string) {\r\n    if (!this.exists(startId)) {\r\n      throw new Error(`${startId} does not exist.`);\r\n    }\r\n    if (!this.exists(idLookingFor)) {\r\n      throw new Error(`${idLookingFor} does not exist.`);\r\n    }\r\n    if (startId == idLookingFor) return true;\r\n    const startNode = this.nodes[startId];\r\n    if (startNode.prev == idLookingFor) return true;\r\n    let prev = startNode.prev;\r\n    while (prev) {\r\n      if (prev == idLookingFor) {\r\n        prev = false;\r\n        return true;\r\n      }\r\n      const newNode = this.nodes[prev];\r\n      prev = newNode.prev;\r\n      if (prev == \"head\") break;\r\n    }\r\n    return false;\r\n  }\r\n  isAfter(startId: string, idLookingFor: string) {\r\n    if (!this.exists(startId)) {\r\n      throw new Error(`${startId} does not exist.`);\r\n    }\r\n    if (!this.exists(idLookingFor)) {\r\n      throw new Error(`${idLookingFor} does not exist.`);\r\n    }\r\n    if (startId == idLookingFor) return true;\r\n    const startNode = this.nodes[startId];\r\n    if (startNode.next == idLookingFor) return true;\r\n    let next = startNode.next;\r\n    while (next) {\r\n      if (next == idLookingFor) {\r\n        next = false;\r\n        return true;\r\n      }\r\n      const newNode = this.nodes[next];\r\n      next = newNode.prev;\r\n      if (next == \"tail\") break;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n```\r\n","id":"use-for-doubly-linked-list-in-javascript"},"__N_SSG":true}