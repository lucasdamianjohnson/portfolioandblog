{"pageProps":{"data":{"title":"Concurrency and Parallelism in JavaScript","description":"How to implement concurrency and parallelism in JavaScript.","date":"2021-11-01","banner":" { \"src\" : \"/images/voxel.jpg\", \"alt\":\"sup\" } ","id":"concurrency-and-parallelism-in-javascript"},"content":"\r\nToday I want to cover how you can implement concurrency parallelism in JavaScript. When I was a computer science student I heard other students and even faculty members say that it was on the hardest subjects and task to master and implement.  But thankfully JavaScript handles the biggest problems of deterring when something is done and sharing data safely between threads. So, now you don't have to deal with the dread and can easily implement a way to boost performance greatly in your application.\r\n\r\nChances are if you have just been doing standard web development there has not been much need or use for these kinds of things. With the exception being service workers to server and cache static resources. However, let's consider a highly resource-intensive application like a game or a 3D modeling program. With something like a modern JavaScript 3D game engine like Three.JS or Babylon.JS, you can easily get some models rendering on the screen but what if then you have to perform an expensive calculation like rebuilding a mesh or doing some complicated game logic?\r\n\r\nWell if the entire application runs in the main thread this will cause the user to experience either immense slowdowns or lockups. And that of course is something that no one really wants to experience when using an app or playing a game. This of course can be caused by simply not utilizing the full power of the machine that the software is running on.\r\n\r\nSo, this is where Typed Arrays, Web Workers, Shared Array Buffers, and Transferable Objects come in. If you do not know what those are I will explain each briefly here.\r\n\r\n### Typed Arrays & Array Buffers\r\n\r\nA typed array is a special type of array that represents information using only byte data. For instance you can create an array of 32 signed floating point numbers or an array of un signed 8 bit numbers. These are important to know when working with multi threading because currently the only information that can be shared between threads are array buffers which are created from and can be used to create and share typed arrays. \r\n\r\n### Web Worker\r\n\r\nA web worker is a separate process started by the browser and instantiated through JavaScript. Each runs in it's own separate context. Meaning you do not have direct access to a web worker from any other web worker or the main thread. You can only communicate by sending messages back and forward using the specified API. \r\n\r\n### Shared Array Buffers\r\n\r\nA Shared Array Buffer is a fixed-length array that can be shared between two separate contexts. The array can only store numbers in the form of different Typed Arrays.  \r\n\r\nNote: This feature is supported in modern browsers but best used in a Chromium base (for now at least). A while ago it did cause some security vulnerabilities and was taken out of spec but since has been patched and put back.\r\n\r\n### Transferable Objects\r\n\r\nA transferable is a special object that can be transferred from one context to another and can only be accessed in one context at a time. They are not typically normal JavaScript objects. They are things like Typed Arrays and HTML Canvases for off screen rendering. This is important because in normal communication with a web worker messages are serialized and de-serialized. This is normally not that big of a deal until the size of the data increases. De-serializing a big object from a web worker on the main thread will cause performance issues and even mitigate all of the benefits of moving the intensive process outside of the main thread. \r\n\r\nIf you want to see a full list of what all can be transferred here is the MDN docs on transferable objects: link\r\n\r\nSo the goal in mind here is to try to keep the communication between the main thread and the web workers as minimal and as fast as possible. While at the same time working with the challenge of sharing useful information between threads given the limited representation given by Typed Arrays. \r\n\r\n### Other Things To Note\r\n\r\nOther things you might come across when looking into this subject would be things like web assembly and so on. I will not cover that here but that is another option for running low level code quickly and getting the result back into JavaScript. However, that heavily relies on your specific use cases and what browsers you are trying to support. As a standard web worker may just be good enough or even better if you are making an app that you know will run on top of the V8 engine; such as an Electron app.\r\n\r\n---\r\n\r\n## Example Use Cases\r\n\r\nSo now I will show each of these things in action in relation to the example I provided above. I am currently developing a voxel engine in TypeScript so I will show how I actually used each of these. I am going to be using TypeScript for these examples but they all can be converted into JS.\r\n\r\nFirst, let's start with setting up a web worker. Which looks like this:\r\n\r\n```ts\r\nfunction createWorldWorker() {\r\n  const worldGen = new Worker(\r\n    new URL(\"../Contexts/worker.js\", import.meta.url),\r\n    {\r\n      type: \"module\",\r\n    }\r\n  );\r\n  worldGen.onerror = (er: ErrorEvent) => {\r\n    console.log(er);\r\n  };\r\n  worldGen.onmessage = (event: MessageEvent) => {\r\n    //do stuff\r\n  };\r\n  return worldGen;\r\n}\r\n```\r\n\r\nYou could have this in a class or a stand-alone function like this. But here you can see that we pass to the Worker constructor the relative path from the current script to the worker script. The second parameter is an options object. In that object type is set to 'module' so we can import ES6 modules into the web worker. \r\n\r\nAfter we set the worker up next, what we have to do is set up the worker's onmessage and onerror functions. This is where you will set up communication between the main thread and the worker thread.\r\n\r\nNow lets us look at inside the worker:\r\n\r\n```ts\r\n//Inside web worker\r\n//Listen for messages from main\r\naddEventListener(\"message\", (event: MessageEvent) => {\r\n  const eventData = event.data;\r\n  //do something with data\r\n});\r\n\r\n//Send Messages To Main\r\nconst worker = self;\r\nfunction sendMessageToMain(data: any) {\r\n  worker.postMessage(data);\r\n}\r\n```\r\n\r\nSo, now we have successfully set up communication between two separate threads.\r\n\r\nNow that we got our workers set up, what are we going to use them for? Well in this example let's say we have a worker that generates a game world procedurally and builds a 3D model from it. A 3D model can be created from scratch in a game engine like Three.Js and Babylon.JS (even plain gl if you want to do it yourself) by providing a set of vertices and index pairs for the vertices that specify the faces of the mesh and their orientation. We can also supply UV coordinates to texture the model and calculate its color to do “light baking”. But all of which can be a tremendous amount of data.\r\n\r\nLet's say for any given area 16×16 meters of the game world there could be potentially a model with a quarter of a million or more vertices. Sending all that data through the normal postMessage causes those huge arrays to be serialized and then deserialized on the main thread which would grind the program to halt.\r\n\r\nSo, what can we do? This is where we can use transferable objects.\r\n\r\nHere is an example of that in action:\r\n\r\n---\r\n\r\n#### In Worker\r\n\r\n```ts\r\ntype MeshData = {\r\n  positions: number[];\r\n  indices: number[];\r\n  colors: number[];\r\n  uvs: number[];\r\n};\r\nfunction sendWorldDataData(\r\n  message: \"new\" | \"update\",\r\n  positionX: number,\r\n  positionZ: number,\r\n  data: MeshData\r\n) {\r\n  const positionArray = new Float32Array(data.positions);\r\n  const indicesArray = new Int32Array(data.indices);\r\n  const colorsArray = new Float32Array(data.colors);\r\n  const uvArray = new Float32Array(data.uvs);\r\n  worker.postMessage(\r\n    [\r\n      message,\r\n      positionX,\r\n      positionZ,\r\n      positionArray.buffer,\r\n      indicesArray.buffer,\r\n      colorsArray.buffer,\r\n      uvArray.buffer,\r\n    ],\r\n    \"/\",\r\n    [\r\n      positionArray.buffer,\r\n      indicesArray.buffer,\r\n      colorsArray.buffer,\r\n      uvArray.buffer,\r\n    ]\r\n  );\r\n}\r\n```\r\n\r\n#### In Main Thread\r\n\r\n```ts\r\nworker.onmessage = (event: MessageEvent) => {\r\n  const eventData = event.data;\r\n  const message = eventData[0];\r\n  if (message == \"new\") {\r\n    const x = eventData[1];\r\n    const z = eventData[2];\r\n    buildNewMesh(x, z, eventData);\r\n  }\r\n};\r\nfunction buildNewMesh(positionX: number, positionZ: number, data: any) {\r\n  const positions = new Float32Array(data[2]);\r\n  const indices = new Int32Array(data[3]);\r\n  const colors = new Float32Array(data[4]);\r\n  const uvs = new Float32Array(data[5]);\r\n  const newMesh = meshBuilder.makeMesh(\r\n    positionX,\r\n    positionZ,\r\n    positions,\r\n    indices,\r\n    colors,\r\n    uvs\r\n  );\r\n  this.meshes[positionX] ??= [];\r\n  this.meshes[positionX][positionZ] = newMesh;\r\n}\r\n```\r\n\r\n---\r\n\r\nAs you can see before we send the data to the main thread we create array buffers from the original data arrays. And then on the main thread, it only has to de-serialize the data's intent and the model's new position To get the arrays back from the array buffers we just make a new Typed Array from the buffer. Make sure that you use the same Typed Array in the worker and main thread otherwise it could cause problems.\r\n\r\n## Can This Go Faster Though?\r\n\r\nWell if you noticed we only created one other process off of main. But what if we could have more? So, in this 3D example let's imagine that the worker we just created instead of itself calculating all of the mesh data it sends a condensed sort of template to another worker that builds the mesh data and sends that to the main.\r\n\r\nThis is where we can use something called a Message Port to connect other workers together. So, in this example, we are going to create an array of workers that will be sent the model's template data. The number of workers will be calculated by the machine's thread count which we can get by using:\r\n\r\n```ts\r\nconst numWorkers = window.navigator.hardwareConcurrency;\r\n```\r\n\r\nYou could probably get away with using half or less but in this example, I am just showing that you can try to use the entire CPU if you want.\r\n\r\nBut here is what that would look like:\r\n\r\n---\r\n\r\n#### In Main Thread\r\n\r\n```ts\r\nworker.onmessage = (event: MessageEvent) => {\r\n  const eventData = event.data;\r\n  const message = eventData[0];\r\n  if (message == \"new\") {\r\n    const x = eventData[1];\r\n    const z = eventData[2];\r\n    buildNewMesh(x, z, eventData);\r\n  }\r\n};\r\nfunction buildNewMesh(positionX: number, positionZ: number, data: any) {\r\n  const chunkMesh = this._getChunkMesh();\r\n  chunkMesh.setEnabled(true);\r\n\r\n  const positions = new Float32Array(data[2]);\r\n  const indices = new Int32Array(data[3]);\r\n  const colors = new Float32Array(data[4]);\r\n  const uvs = new Float32Array(data[5]);\r\n  const newChunk = this.chunkBuilder.makeChunkMesh(\r\n    chunkMesh,\r\n    positionX,\r\n    positionZ,\r\n    this.material,\r\n    positions,\r\n    indices,\r\n    colors,\r\n    uvs\r\n  );\r\n  //chunkMesh.updateFacetData();\r\n  this.chunkMeshes[positionX] ??= [];\r\n  this.chunkMeshes[positionX][positionZ] = newChunk;\r\n}\r\n\r\nfunction createBuilders(world: Worker) {\r\n  const numBuilders = window.navigator.hardwareConcurrency;\r\n  for (let i = 0; i < numBuilders; i++) {\r\n    this.builders[i] = new Worker(\r\n      new URL(\r\n        \"../Contexts/MeshBuilders/ChunkMeshBuilder.worker.js\",\r\n        import.meta.url\r\n      ),\r\n      {\r\n        type: \"module\",\r\n      }\r\n    );\r\n    this.builders[i].onerror = (er: ErrorEvent) => {\r\n      console.log(er);\r\n    };\r\n    this.builders[i].onmessage = async (event) => {\r\n      this._handleMeshBuildEvent(event);\r\n    };\r\n\r\n    const channel = new MessageChannel();\r\n    const builderWorker = this.builders[i];\r\n\r\n    // Setup the connection: Port 1 is for worker 1\r\n    world.postMessage([\"connect-builder\"], [channel.port1]);\r\n\r\n    // Setup the connection: Port 2 is for worker 2\r\n    builderWorker.postMessage([\"connect-world\"], [channel.port2]);\r\n  }\r\n}\r\n```\r\n\r\n#### In World Worker\r\n\r\n```ts\r\nclass BuildManager {\r\n  count = 0;\r\n  numBuilders = 0;\r\n  mainThreadCom: Worker;\r\n  builders: MessagePort[] = [];\r\n\r\n  addBuilder(port: MessagePort) {\r\n    this.builders.push(port);\r\n    this.numBuilders++;\r\n  }\r\n  requestChunkBeBuilt(\r\n    chunkX: number,\r\n    chunkZ: number,\r\n    meshTemplate: number[][]\r\n  ) {\r\n    this.count++;\r\n    if (this.count >= this.numBuilders) {\r\n      this.count = 0;\r\n    }\r\n    const positions = new Uint16Array(meshTemplate[0]);\r\n    const indices = new Uint8Array(meshTemplate[1]);\r\n    const blocks = new Uint16Array(meshTemplate[2]);\r\n    const groups = new Float32Array(meshTemplate[3]);\r\n    const ambientOcclusion = new Float32Array(meshTemplate[4]);\r\n\r\n    this.builders[this.count].postMessage([\r\n      chunkX,\r\n      chunkZ,\r\n      positions.buffer,\r\n      indices.buffer,\r\n      blocks.buffer,\r\n      groups.buffer,\r\n      ambientOcclusion.buffer,\r\n    ]),\r\n      [\r\n        positions.buffer,\r\n        indices.buffer,\r\n        blocks.buffer,\r\n        ambientOcclusion.buffer,\r\n      ];\r\n  }\r\n}\r\nconst builderManager = new BuildManager();\r\n\r\naddEventListener(\"message\", (event: MessageEvent) => {\r\n  const eventData = event.data;\r\n  const message = eventData[0];\r\n\r\n  if (message == \"connect-builder\") {\r\n    const port = event.ports[0];\r\n    builderManager.addBuilder(port);\r\n  }\r\n});\r\n\r\n```\r\n\r\n#### In Builder Worker\r\n\r\n```ts\r\nconst worker = self;\r\n//mesh builder\r\nconst builder: any = {};\r\n\r\nfunction sendChunkData(chunkX: number, chunkZ: number, data: MeshData) {\r\n  const positionArray = new Float32Array(data.positions);\r\n  const indicesArray = new Int32Array(data.indices);\r\n  const colorsArray = new Float32Array(data.colors);\r\n  const uvArray = new Float32Array(data.uvs);\r\n  worker.postMessage(\r\n    [\r\n      chunkX,\r\n      chunkZ,\r\n      positionArray.buffer,\r\n      indicesArray.buffer,\r\n      colorsArray.buffer,\r\n      uvArray.buffer,\r\n    ],\r\n    \"/\",\r\n    [\r\n      positionArray.buffer,\r\n      indicesArray.buffer,\r\n      colorsArray.buffer,\r\n      uvArray.buffer,\r\n    ]\r\n  );\r\n}\r\n\r\nconst messageFromWorld = (event: MessageEvent) => {\r\n  const data = event.data;\r\n\r\n  const positionX = data[0];\r\n  const positionZ = data[1];\r\n  const meshPositions = new Uint16Array(data[2]);\r\n  const meshIndices = new Uint8Array(data[3]);\r\n  const meshBlocks = new Uint16Array(data[4]);\r\n  const meshGroups = new Float32Array(data[5]);\r\n  const meshAO = new Float32Array(data[6]);\r\n  const meshData = builder.buildMesh(\r\n    positionX,\r\n    positionZ,\r\n    meshPositions,\r\n    meshIndices,\r\n    meshBlocks,\r\n    meshGroups,\r\n    meshAO\r\n  );\r\n\r\n  sendChunkData(positionX, positionZ, meshData);\r\n};\r\naddEventListener(\"message\", (event: MessageEvent) => {\r\n  const data = event.data;\r\n  const message = data[0];\r\n\r\n  if (message == \"connect-world\") {\r\n    const port = event.ports[0];\r\n\r\n    port.onmessage = (event: MessageEvent) => {\r\n      messageFromWorld(event);\r\n    };\r\n  }\r\n});\r\n```\r\n\r\n---\r\n\r\nAs you can see we create a few instances of the builder worker and when it is time to build a new model we send it just the template. It then constructs the model and sends it to the main thread. So, with this set up you could build as many meshes as you have workers. But all of this stuff is happening more or less concurrently. What about parallelism?\r\n\r\n## Parallelism\r\n\r\nWell, I am going to give a simple example but should give you a good idea of what you can do with a Shared Array Buffer.\r\n\r\nThe thing you need to note with a Shared Array Buffer is that they are a fixed size and must be declared their size at the start. You define the size by the number of bytes. So, if you need an array of 3 32 bit floats you would need 12 bytes 4 bytes for each number. Then in order to use the array-like, it is an array of 32 bit floats you must create a TypedArray from it that is also a 32BitFloat. And of course, we are using signed bytes so we can go in the negative also.\r\n\r\nAnother thing to note in this example. I have one thread write and one thread read. You could run into problems if you are having multiple threads read and write at the same time. If you are doing this please check into Atomics: link\r\n\r\nIt basically ensures thread safety when reading and writing shared data across multiple contexts.\r\n\r\nSo, a use case for the game example would be keeping track of the player's position and doing something based on where they moved or where they are looking. What we can do actually is continually load the player's position into the array with the shared array buffer. And from any other context that we share that buffer too can also access where the player is at. \r\n\r\nHere is that implemented: \r\n\r\n\r\n---\r\n\r\n#### In Main Thread\r\n\r\n```ts\r\nclass Player {\r\n  position = { x: 0, y: 0, z: 0 };\r\n  sharedPositionArrayBuffer = new SharedArrayBuffer(12);\r\n  sharedPositionArray = new Float32Array(this.sharedPositionArrayBuffer);\r\n  update() {\r\n    this.sharedPositionArray[0] = this.position.x;\r\n    this.sharedPositionArray[1] = this.position.y;\r\n    this.sharedPositionArray[2] = this.position.z;\r\n  }\r\n}\r\n//Get a worker - Just used for example\r\nconst worldWorker: Worker = <Worker>{};\r\nconst player = new Player();\r\nworldWorker.postMessage(\r\n  [\"connect-player\", player.sharedPositionArrayBuffer],\r\n  [player.sharedPositionArrayBuffer]\r\n);\r\n//game update loop\r\nsetInterval(() => {\r\n  player.update();\r\n}, 50);\r\n\r\n```\r\n\r\n#### In Worker\r\n\r\n```ts\r\nclass PlayerWatcher {\r\n  playerABSPositon: Float32Array;\r\n  cachedPlayerX: number;\r\n  cachedPlayerZ: number;\r\n  cachedZone: number[];\r\n  calculateGameZone(positionX: number, positionZ: number) {\r\n    const zonePositionX = (positionX >> 4) << 4;\r\n    const zonePositionZ = (positionZ >> 4) << 4;\r\n    return [zonePositionX, zonePositionZ];\r\n  }\r\n\r\n  setPlayerSharedArrays(postionBuffer: SharedArrayBuffer) {\r\n    this.playerABSPositon = new Float32Array(postionBuffer);\r\n  }\r\n  startWatchingPlayer() {\r\n    this.cachedPlayerX = this.playerABSPositon[0];\r\n    this.cachedPlayerZ = this.playerABSPositon[1];\r\n    const zone = this.calculateGameZone(\r\n      this.playerABSPositon[0],\r\n      this.playerABSPositon[1]\r\n    );\r\n    this.cachedZone = zone;\r\n    setInterval(() => {\r\n      let movedX = false;\r\n      if (this.cachedPlayerX != this.playerABSPositon[0]) {\r\n        movedX = true;\r\n      }\r\n      let movedZ = false;\r\n      if (this.cachedPlayerZ != this.playerABSPositon[1]) {\r\n        movedZ = true;\r\n      }\r\n      const zone = this.calculateGameZone(\r\n        this.playerABSPositon[0],\r\n        this.playerABSPositon[1]\r\n      );\r\n      let zoneXChanged = false;\r\n      if (zone[0] != this.cachedZone[0]) {\r\n        zoneXChanged = true;\r\n      }\r\n      let zoneZChanged = false;\r\n      if (zone[1] != this.cachedZone[1]) {\r\n        zoneZChanged = true;\r\n      }\r\n      this.cachedZone = zone;\r\n      this.cachedPlayerX = this.playerABSPositon[0];\r\n      this.cachedPlayerZ = this.playerABSPositon[1];\r\n    }, 50);\r\n  }\r\n}\r\nconst playerWatcher = new PlayerWatcher();\r\nconst worker = self;\r\naddEventListener(\"message\", (event: MessageEvent) => {\r\n  const eventData = event.data;\r\n  const message = eventData[0];\r\n\r\n  if (message == \"connect-player\") {\r\n    playerWatcher.setPlayerSharedArrays(event.data[1]);\r\n    playerWatcher.startWatchingPlayer();\r\n  }\r\n});\r\n```\r\n\r\n---\r\n\r\nIn the player class, we are just getting the player's position and setting that in the shared array. While in the worker we are just reading that data from the array. So, in this way we can react instantaneously and in parallel to the player's updated position. Pretty cool huh? We don't have to fuss with postMessage or message events at all.\r\n\r\n## Conclusion\r\n\r\nAchieving parallelism and concurrency is not that hard in JavaScript. It could be a great benefit to your application to offload as much as you could to the separate threads. Though I would always say don't prematurely optimize and realize the consequences of having many workers and sharing lots of data between them. Make sure to always test the actual effects of using a worker. There is still the potential for memory leaks and performance hits. It's really about striking a balance.\r\n\r\nOther things you could consider are things like web assembly and if you are doing game programming you could maybe move some intensive actions to the GPU like UV animations on a model.\r\n","id":"concurrency-and-parallelism-in-javascript"},"__N_SSG":true}